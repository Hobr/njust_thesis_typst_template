@article{dagenais_lude_1993,
	title = {{LUDE}: {A} {Distributed} {Software} {Library}},
	abstract = {Numerous software packages are being used and updated regularly on most computer systems. Installing all these software packages is a formidable task because each one has a different procedure for compiling or for placing the ﬁles required at run time. The LUDE (Logithèque Universitaire Distribuée et Extensible) software library is an organization for installing software packages, a set of tools to install and uninstall software packages and browse their documentation, and a number of FTP servers offering over 100 pre-installed freely redistributable software packages. It offers functionality and ﬂexibility not available in existing systems.},
	language = {en},
	author = {Dagenais, Michel and Boucher, Stéphane and Research, Bell-Northern and Gérin-Lajoie, Robert and Laplante, Pierre and Mailhot, Pierre},
	year = {1993},
	file = {Dagenais 等 - 1993 - LUDE A Distributed Software Library.pdf:/home/kanade/Zotero/storage/ESE4FPPH/Dagenais 等 - 1993 - LUDE A Distributed Software Library.pdf:application/pdf},
}

@article{greenwade_comprehensive_1993,
	title = {The {Comprehensive} {TEXArchve} {Network} ({CTAN})},
	volume = {14},
	abstract = {T h s paper outlines the concept, development, and use of the Comprehensive TEX Archive Network (CTAN)-a network-accessible archve for files related to the TEX family of document processing. The CTAN is a coordinated effort among consenting well-known archve sites which provides quick identification and retrieval files in a consistent manner from hosts on different continents, thereby reducing overall network load and increasing speed of retrieval. Moreover, it provides users with a parallel archive structure between hosts with holdings whch are generally synchronized to w i t h 30 hours of one another. This is achieved by routinely mirroring one another's holdings, as well as mirroring other archves to maintain an up-to-date collection of files.},
	language = {en},
	number = {3},
	author = {Greenwade, George D},
	year = {1993},
	file = {Greenwade - 1993 - The Comprehensive TEXArchve Network (CTAN).pdf:/home/kanade/Zotero/storage/BHGA65BY/Greenwade - 1993 - The Comprehensive TEXArchve Network (CTAN).pdf:application/pdf},
}

@article{dolstra_nix_2004,
	title = {Nix: {A} {Safe} and {Policy}-{Free} {System} for {Software} {Deployment}},
	abstract = {Existing systems for software deployment are neither safe nor sufficiently flexible. Primary safety issues are the inability to enforce reliable specification of component dependencies, and the lack of support for multiple versions or variants of a component. This renders deployment operations such as upgrading or deleting components dangerous and unpredictable. A deployment system must also be flexible (i.e., policy-free) enough to support both centralised and local package management, and to allow a variety of mechanisms for transferring components. In this paper we present Nix, a deployment system that addresses these issues through a simple technique of using cryptographic hashes to compute unique paths for component instances.},
	language = {en},
	author = {Dolstra, Eelco and de Jonge, Merijn and Visser, Eelco},
	year = {2004},
	file = {Dolstra 等 - 2004 - Nix A Safe and Policy-Free System for Software De.pdf:/home/kanade/Zotero/storage/PE5FGJKN/Dolstra 等 - 2004 - Nix A Safe and Policy-Free System for Software De.pdf:application/pdf},
}

@inproceedings{serrano_adaptive_2007,
	address = {New York, NY, USA},
	series = {{DLS} '07},
	title = {An adaptive package management system for scheme},
	isbn = {978-1-59593-868-8},
	url = {https://dl.acm.org/doi/10.1145/1297081.1297093},
	doi = {10.1145/1297081.1297093},
	abstract = {This paper presents a package management system for the Scheme programming language. It is inspired by the Comprehensive Perl Archive Network (CPAN) and various GNU/Linux distributions. It downloads, installs, and prepares source codes for execution. It manages the dependencies between packages. The main characteristic of this system is its neutrality with respect to the various Scheme implementations. It is neutral with respect to the language extensions that each Scheme implementation proposes and with respect to the execution environment of these implementations. This allows the programmer to blend, within the same program, independent components which have been developed and tested within different Scheme implementations. ScmPkg is available at: http://hop.inria.fr/scmpkg.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 2007 symposium on {Dynamic} languages},
	publisher = {Association for Computing Machinery},
	author = {Serrano, Manuel and Gallesio, Erick},
	month = oct,
	year = {2007},
	keywords = {functional programming},
	pages = {65--76},
	file = {Full Text PDF:/home/kanade/Zotero/storage/U6Q8MHS5/Serrano 和 Gallesio - 2007 - An adaptive package management system for scheme.pdf:application/pdf},
}

@inproceedings{tucker_opium_2007,
	address = {USA},
	series = {{ICSE} '07},
	title = {{OPIUM}: {Optimal} {Package} {Install}/{Uninstall} {Manager}},
	isbn = {978-0-7695-2828-1},
	shorttitle = {{OPIUM}},
	url = {https://dl.acm.org/doi/10.1109/ICSE.2007.59},
	doi = {10.1109/ICSE.2007.59},
	abstract = {Linux distributions often include package management tools such as apt-get in Debian or yum in RedHat. Using information about package dependencies and conflicts, such tools can determine how to install a new package (and its dependencies) on a system of already installed packages. Using off-the-shelf SAT solvers, pseudo-boolean solvers, and Integer Linear Programming solvers, we have developed a new package-management tool, called Opium, that improves on current tools in two ways: (1) Opium is complete, in that if there is a solution, Opium is guaranteed to find it, and (2) Opium can optimize a user-provided objective function, which could for example state that smaller packages should be preferred over larger ones. We performed a comparative study of our tool against Debian's apt-get on 600 traces of real-world package installations. We show that Opium runs fast enough to be usable, and that its completeness and optimality guarantees provide concrete benefits to end users.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 29th international conference on {Software} {Engineering}},
	publisher = {IEEE Computer Society},
	author = {Tucker, Chris and Shuffelton, David and Jhala, Ranjit and Lerner, Sorin},
	month = may,
	year = {2007},
	pages = {178--188},
	file = {Full Text PDF:/home/kanade/Zotero/storage/8J24IQFQ/Tucker 等 - 2007 - OPIUM Optimal Package InstallUninstall Manager.pdf:application/pdf},
}

@inproceedings{dolstra_nixos_2008,
	address = {New York, NY, USA},
	series = {{ICFP} '08},
	title = {{NixOS}: a purely functional {Linux} distribution},
	isbn = {978-1-59593-919-7},
	shorttitle = {{NixOS}},
	url = {https://dl.acm.org/doi/10.1145/1411204.1411255},
	doi = {10.1145/1411204.1411255},
	abstract = {Existing package and system configuration management tools suffer from an imperative model, where system administration actions such as upgrading packages or changes to system configuration files are stateful: they destructively update the state of the system. This leads to many problems, such as the inability to roll back changes easily, to run multiple versions of a package side-by-side, to reproduce a configuration deterministically on another machine, or to reliably upgrade a system. In this paper we show that we can overcome these problems by moving to a purely functional system configuration model. This means that all static parts of a system (such as software packages, configuration files and system startup scripts) are built by pure functions and are immutable, stored in a way analogously to a heap in a purely function language. We have implemented this model in NixOS, a non-trivial Linux distribution that uses the Nix package manager to build the entire system configuration from a purely functional specification.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {Association for Computing Machinery},
	author = {Dolstra, Eelco and Löh, Andres},
	month = sep,
	year = {2008},
	keywords = {nix, NixOS, package management, purely functional deployment model, purely functional language, software deployment, system configuration management},
	pages = {367--378},
	file = {Full Text PDF:/home/kanade/Zotero/storage/5KXT6AAX/Dolstra 和 Löh - 2008 - NixOS a purely functional Linux distribution.pdf:application/pdf},
}

@article{hornik_comprehensive_2012,
	title = {The {Comprehensive} {R} {Archive} {Network}},
	volume = {4},
	copyright = {Copyright © 2012 Wiley Periodicals, Inc.},
	issn = {1939-0068},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/wics.1212},
	doi = {10.1002/wics.1212},
	abstract = {The Comprehensive R Archive Network (CRAN) is a network of sites acting as the primary web service distributing R sources and binaries, extension packages, and documentation. We discuss this functionality in more detail, with particular emphasis on the CRAN package repository, and its underlying design and operation principles. WIREs Comput Stat 2012 doi: 10.1002/wics.1212 This article is categorized under: Applications of Computational Statistics {\textgreater} Organizations and Publications},
	language = {en},
	number = {4},
	urldate = {2024-05-14},
	journal = {WIREs Computational Statistics},
	author = {Hornik, Kurt},
	year = {2012},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/wics.1212},
	keywords = {collaborative software development, knowledge domain, R, R package repositories, R sources and binaries, software quality, statistical computing},
	pages = {394--398},
	file = {Full Text PDF:/home/kanade/Zotero/storage/6N3X67AS/Hornik - 2012 - The Comprehensive R Archive Network.pdf:application/pdf;Snapshot:/home/kanade/Zotero/storage/PLLZPD4A/wics.html:text/html},
}

@inproceedings{cappos_look_2008,
	address = {New York, NY, USA},
	series = {{CCS} '08},
	title = {A look in the mirror: attacks on package managers},
	isbn = {978-1-59593-810-7},
	shorttitle = {A look in the mirror},
	url = {https://dl.acm.org/doi/10.1145/1455770.1455841},
	doi = {10.1145/1455770.1455841},
	abstract = {This work studies the security of ten popular package managers. These package managers use different security mechanisms that provide varying levels of usability and resilience to attack. We find that, despite their existing security mechanisms, all of these package managers have vulnerabilities that can be exploited by a man-in-the-middle or a malicious mirror. While all current package managers suffer from vulnerabilities, their security is also positively or negatively impacted by the distribution's security practices. Weaknesses in package managers are more easily exploited when distributions use third-party mirrors as official mirrors. We were successful in using false credentials to obtain an official mirror on all five of the distributions we attempted. We also found that some security mechanisms that control where a client obtains metadata and packages from may actually decrease security. We analyze current package managers to show that by exploiting vulnerabilities, an attacker with a mirror can compromise or crash hundreds to thousands of clients weekly. The problems we disclose are now being corrected by many different package manager maintainers.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 15th {ACM} conference on {Computer} and communications security},
	publisher = {Association for Computing Machinery},
	author = {Cappos, Justin and Samuel, Justin and Baker, Scott and Hartman, John H.},
	month = oct,
	year = {2008},
	keywords = {package management, mirrors, replay attack},
	pages = {565--574},
	file = {Full Text PDF:/home/kanade/Zotero/storage/WI8IGEBK/Cappos 等 - 2008 - A look in the mirror attacks on package managers.pdf:application/pdf},
}

@inproceedings{mancinelli_managing_2006,
	address = {Tokyo},
	title = {Managing the {Complexity} of {Large} {Free} and {Open} {Source} {Package}-{Based} {Software} {Distributions}},
	isbn = {978-0-7695-2579-2},
	url = {https://ieeexplore.ieee.org/document/4019575/},
	doi = {10.1109/ASE.2006.49},
	abstract = {The widespread adoption of Free and Open Source Software (FOSS) in many strategic contexts of the information technology society has drawn the attention on the issues regarding how to handle the complexity of assembling and managing a huge number of (packaged) components in a consistent and effective way. FOSS distributions (and in particular GNU/Linux-based ones) have always provided tools for managing the tasks of installing, removing and upgrading the (packaged) components they were made of. While these tools provide a (not always effective) way to handle these tasks on the client side, there is still a lack of tools that could help the distribution editors to maintain, on the server side, large and high-quality distributions. In this paper we present our research whose main goal is to ﬁll this gap: we show our approach, the tools we have developed and their application with experimental results. Our contribution provides an effective and automatic way to support distribution editors in handling those issues that were, until now, mostly addressed using ad-hoc tools and manual techniques.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {21st {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering} ({ASE}'06)},
	publisher = {IEEE},
	author = {Mancinelli, Fabio and Boender, Jaap and Di Cosmo, Roberto and Vouillon, Jerome and Durak, Berke and Leroy, Xavier and Treinen, Ralf},
	month = sep,
	year = {2006},
	pages = {199--208},
	file = {Mancinelli 等 - 2006 - Managing the Complexity of Large Free and Open Sou.pdf:/home/kanade/Zotero/storage/Y8Z864LN/Mancinelli 等 - 2006 - Managing the Complexity of Large Free and Open Sou.pdf:application/pdf},
}

@inproceedings{di_cosmo_package_2008,
	title = {Package upgrades in {FOSS} distributions: details and challenges},
	shorttitle = {Package upgrades in {FOSS} distributions},
	url = {http://arxiv.org/abs/0902.1610},
	doi = {10.1145/1490283.1490292},
	abstract = {The upgrade problems faced by Free and Open Source Software distributions have characteristics not easily found elsewhere. We describe the structure of packages and their role in the upgrade process. We show that state of the art package managers have shortcomings inhibiting their ability to cope with frequent upgrade failures. We survey current countermeasures to such failures, argue that they are not satisfactory, and sketch alternative solutions.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 1st {International} {Workshop} on {Hot} {Topics} in {Software} {Upgrades}},
	author = {Di Cosmo, Roberto and Zacchiroli, Stefano and Trezentos, Paulo},
	month = oct,
	year = {2008},
	note = {arXiv:0902.1610 [cs]},
	keywords = {Computer Science - Operating Systems, Computer Science - Software Engineering, distribution, FOSS, packages, rollback, upgrade},
	pages = {1--5},
	file = {全文:/home/kanade/Zotero/storage/35RLYQ2P/Di Cosmo 等 - 2008 - Package upgrades in FOSS distributions details an.pdf:application/pdf;arXiv.org Snapshot:/home/kanade/Zotero/storage/BSLURWTN/0902.html:text/html},
}

@article{dagnat_toward_nodate,
	title = {Toward {Decentralized} {Package} {Management}},
	language = {en},
	author = {Dagnat, Fabien and Simon, Gwendal and Zhang, Xu},
	file = {Dagnat 等 - Toward Decentralized Package Management.pdf:/home/kanade/Zotero/storage/Y38I2Y4M/Dagnat 等 - Toward Decentralized Package Management.pdf:application/pdf},
}

@article{abate_modular_2013,
	title = {A modular package manager architecture},
	volume = {55},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {09505849},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0950584912001851},
	doi = {10.1016/j.infsof.2012.09.002},
	abstract = {The success of modern software distributions in the Free and Open Source world can be explained, among other factors, by the availability of a large collection of software packages and the possibility to easily install and remove those components using state-of-the-art package managers. However, package managers are often built using a monolithic architecture and hard-wired and ad-hoc dependency solvers implementing some customized heuristics.},
	language = {en},
	number = {2},
	urldate = {2024-05-14},
	journal = {Information and Software Technology},
	author = {Abate, Pietro and Di Cosmo, Roberto and Treinen, Ralf and Zacchiroli, Stefano},
	month = feb,
	year = {2013},
	pages = {459--474},
	file = {Abate 等 - 2013 - A modular package manager architecture.pdf:/home/kanade/Zotero/storage/3272TNUA/Abate 等 - 2013 - A modular package manager architecture.pdf:application/pdf},
}

@article{vouillon_software_2013,
	title = {On software component co-installability},
	volume = {22},
	issn = {1049-331X},
	url = {https://dl.acm.org/doi/10.1145/2522920.2522927},
	doi = {10.1145/2522920.2522927},
	abstract = {Modern software systems are built by composing components drawn from large repositories, whose size and complexity is increasing at a very fast pace. A fundamental challenge for the maintainability and the scalability of such software systems is the ability to quickly identify the components that can or cannot be installed together: this is the co-installability problem, which is related to boolean satisfiability and is known to be algorithmically hard. This article develops a novel theoretical framework, based on formally certified semantic preserving graph-theoretic transformations, that allows us to associate to each concrete component repository a much smaller one with a simpler structure, that we call strongly flat, with equivalent co-installability properties. This flat repository can be displayed in a way that provides a concise view of the co-installability issues in the original repository, or used as a basis for various algorithms related to co-installability, like the efficient computation of strong conflicts between components. The proofs contained in this work have been machine checked using the Coq proof assistant.现代软件系统是通过组合从大型存储库中提取的组件来构建的，这些存储库的规模和复杂性正在以非常快的速度增加。此类软件系统的可维护性和可扩展性的一个基本挑战是能够快速识别可以或不能一起安装的组件：这就是共安装性问题，它与布尔满足性有关，并且已知在算法上很难。本文开发了一种新的理论框架，该框架基于正式认证的语义保留图论转换，它允许我们将一个更小的、结构更简单的组件存储库与每个具体组件存储库相关联，我们称之为强扁平化，具有等效的可安装性。这种扁平存储库的显示方式可以提供原始存储库中可安装性问题的简明视图，也可以用作与可安装性相关的各种算法的基础，例如组件之间强冲突的有效计算。本作品中包含的校样已使用 Coq 校样助手进行了机器检查。},
	number = {4},
	urldate = {2024-05-14},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Vouillon, Jérôme and Cosmo, Roberto Di},
	month = oct,
	year = {2013},
	keywords = {package management, co-installability, Component, conflicts, dependencies, open source},
	pages = {34:1--34:35},
	file = {Full Text PDF:/home/kanade/Zotero/storage/NAWB4LJ2/Vouillon 和 Cosmo - 2013 - On software component co-installability.pdf:application/pdf},
}

@inproceedings{ignatiev_towards_2014,
	address = {New York, NY, USA},
	series = {{ICSE} 2014},
	title = {Towards efficient optimization in package management systems},
	isbn = {978-1-4503-2756-5},
	url = {https://dl.acm.org/doi/10.1145/2568225.2568306},
	doi = {10.1145/2568225.2568306},
	abstract = {Package management as a means of reuse of software artifacts has become extremely popular, most notably in Linux distributions. At the same time, successful package management brings about a number of computational challenges. Whenever a user requires a new package to be installed, a package manager not only installs the new package but it might also install other packages or uninstall some old ones in order to respect dependencies and conflicts of the packages. Coming up with a new configuration of packages is computationally challenging. It is in particular complex when we also wish to optimize for user preferences, such as that the resulting package configuration should not differ too much from the original one. A number of exact approaches for solving this problem have been proposed in recent years. These approaches, however, do not have guaranteed runtime due to the high computational complexity of the problem. This paper addresses this issue by devising a hybrid approach that integrates exact solving with approximate solving by invoking the approximate part whenever the solver is running out of time. Experimental evaluation shows that this approach enables returning high-quality package configurations with rapid response time.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 36th {International} {Conference} on {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Ignatiev, Alexey and Janota, Mikoláš and Marques-Silva, Joao},
	month = may,
	year = {2014},
	keywords = {MaxSAT solving, Minimal Correstion Subsets, Optimization, Package management, SAT solving},
	pages = {745--755},
	file = {Full Text PDF:/home/kanade/Zotero/storage/89UVLM98/Ignatiev 等 - 2014 - Towards efficient optimization in package manageme.pdf:application/pdf},
}

@article{dmello_automatic_nodate,
	title = {Automatic {Software} {Dependency} {Management} using {Blockchain}},
	abstract = {Contemporary software deployments rely on cloud-based package managers for installation, where existing packages are installed on demand from remote code repositories. Usually, frameworks or common utilities, packages increase the code reusability within the ecosystem, whilst keeping the code base small. However, disruptions in the package management services can potentially aﬀect development and deployment workﬂows. Furthermore, cloud package managers have arguably an ambiguous ownership model and oﬀer limited visibility of packages to the users. This work describes the development of a blockchain-based package control system which is decentralised, reliable and transparent. Blockchain nodes are installed within the infrastructure to provide immutability, and then a dependency graph is constructed to trace the software provenance and package reliance. Our system has been tested with 4338 packages from NPM, 950 out of which are the top dependedupon packages.},
	language = {en},
	author = {D’mello, Gavin},
	file = {D’mello - Automatic Software Dependency Management using Blo.pdf:/home/kanade/Zotero/storage/PJL2PUAM/D’mello - Automatic Software Dependency Management using Blo.pdf:application/pdf},
}

@incollection{garcia-alfaro_contour_2018,
	address = {Cham},
	title = {Contour: {A} {Practical} {System} for {Binary} {Transparency}},
	volume = {11025},
	isbn = {978-3-030-00304-3 978-3-030-00305-0},
	shorttitle = {Contour},
	url = {http://link.springer.com/10.1007/978-3-030-00305-0_8},
	abstract = {Transparency is crucial in security-critical applications that rely on authoritative information, as it provides a robust mechanism for holding these authorities accountable for their actions. A number of solutions have emerged in recent years that provide transparency in the setting of certificate issuance, and Bitcoin provides an example of how to enforce transparency in a financial setting. In this work we shift to a new setting, the distribution of software package binaries, and present a system for so-called “binary transparency.” Our solution, Contour, uses proactive methods for providing transparency, privacy, and availability, even in the face of persistent man-in-the-middle attacks. We also demonstrate, via benchmarks and a test deployment for the Debian software repository, that Contour is the only system for binary transparency that satisfies the efficiency and coordination requirements that would make it possible to deploy today.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {Data {Privacy} {Management}, {Cryptocurrencies} and {Blockchain} {Technology}},
	publisher = {Springer International Publishing},
	author = {Al-Bassam, Mustafa and Meiklejohn, Sarah},
	editor = {Garcia-Alfaro, Joaquin and Herrera-Joancomartí, Jordi and Livraga, Giovanni and Rios, Ruben},
	year = {2018},
	doi = {10.1007/978-3-030-00305-0_8},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {94--110},
	file = {Al-Bassam 和 Meiklejohn - 2018 - Contour A Practical System for Binary Transparenc.pdf:/home/kanade/Zotero/storage/R9TBR87A/Al-Bassam 和 Meiklejohn - 2018 - Contour A Practical System for Binary Transparenc.pdf:application/pdf},
}

@inproceedings{diaz_change_2011,
	address = {Berlin, Heidelberg},
	title = {Change {Impact} {Analysis} in {Product}-{Line} {Architectures}},
	isbn = {978-3-642-23798-0},
	doi = {10.1007/978-3-642-23798-0_12},
	abstract = {Change impact analysis is fundamental in software evolution, since it allows one to determine potential effects upon a system resulting from changing requirements. While prior work has generically considered change impact analysis at architectural level, there is a distinct lack of support for the kinds of architectures used to realize software product lines, so-called product-line architectures (PLAs). In particular, prior approaches do not account for variability, a specific characteristic of software product lines. This paper presents a new technique for change impact analysis that targets product-line architectures. We propose to join a traceability-based algorithm and a rule-based inference engine to effectively traverse modeling artifacts that account for variability. In contrast to prior approaches, our technique supports the mechanisms for (i) specifying variability in PLAs, (ii) documenting PLA knowledge, and (iii) tracing variability between requirements and PLAs. We demonstrate our technique by applying it to the analysis of requirements changes in the product-line architecture of a banking system.},
	language = {en},
	booktitle = {Software {Architecture}},
	publisher = {Springer},
	author = {Díaz, Jessica and Pérez, Jennifer and Garbajosa, Juan and Wolf, Alexander L.},
	editor = {Crnkovic, Ivica and Gruhn, Volker and Book, Matthias},
	year = {2011},
	keywords = {change impact analysis, Product-line architectures, product-line evolution},
	pages = {114--129},
	file = {Full Text PDF:/home/kanade/Zotero/storage/YPGXB6YH/Díaz 等 - 2011 - Change Impact Analysis in Product-Line Architectur.pdf:application/pdf},
}

@inproceedings{decan_topology_2016,
	address = {New York, NY, USA},
	series = {{ECSAW} '16},
	title = {On the topology of package dependency networks: a comparison of three programming language ecosystems},
	isbn = {978-1-4503-4781-5},
	shorttitle = {On the topology of package dependency networks},
	url = {https://dl.acm.org/doi/10.1145/2993412.3003382},
	doi = {10.1145/2993412.3003382},
	abstract = {Package-based software ecosystems are composed of thousands of interdependent software packages. Many empirical studies have focused on software packages belonging to a single software ecosystem, and suggest to generalise the results to more ecosystems. We claim that such a generalisation is not always possible, because the technical structure of software ecosystems can be very different, even if these ecosystems belong to the same domain. We confirm this claim through a study of three big and popular package-based programming language ecosystems: R's CRAN archive network, Python's PyPI distribution, and JavaScript's NPM package manager. We study and compare the structure of their package dependency graphs and reveal some important differences that may make it difficult to generalise the findings of one ecosystem to another one.},
	urldate = {2024-05-14},
	booktitle = {Proccedings of the 10th {European} {Conference} on {Software} {Architecture} {Workshops}},
	publisher = {Association for Computing Machinery},
	author = {Decan, Alexandre and Mens, Tom and Claes, Maelick},
	month = nov,
	year = {2016},
	keywords = {R, component dependency graph, JavaScript, Python, software distribution, software ecosystem},
	pages = {1--4},
	file = {Full Text PDF:/home/kanade/Zotero/storage/ND88FGSF/Decan 等 - 2016 - On the topology of package dependency networks a .pdf:application/pdf},
}

@inproceedings{dietrich_dependency_2019,
	address = {Montreal, QC, Canada},
	title = {Dependency {Versioning} in the {Wild}},
	copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html},
	isbn = {978-1-72813-412-3},
	url = {https://ieeexplore.ieee.org/document/8816809/},
	doi = {10.1109/MSR.2019.00061},
	abstract = {Many modern software systems are built on top of existing packages (modules, components, libraries). The increasing number and complexity of dependencies has given rise to automated dependency management where package managers resolve symbolic dependencies against a central repository. When declaring dependencies, developers face various choices, such as whether or not to declare a ﬁxed version or a range of versions. The former results in runtime behaviour that is easier to predict, whilst the latter enables ﬂexibility in resolution that can, for example, prevent different versions of the same package being included and facilitates the automated deployment of bug ﬁxes. We study the choices developers make across 17 different package managers, investigating over 70 million dependencies. This is complemented by a survey of 170 developers. We ﬁnd that many package managers support — and the respective community adapts — ﬂexible versioning practices. This does not always work: developers struggle to ﬁnd the sweet spot between the predictability of ﬁxed version dependencies, and the agility of ﬂexible ones, and depending on their experience, adjust practices. We see some uptake of semantic versioning in some package managers, supported by tools. However, there is no evidence that projects switch to semantic versioning on a large scale.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {2019 {IEEE}/{ACM} 16th {International} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
	publisher = {IEEE},
	author = {Dietrich, Jens and Pearce, David and Stringer, Jacob and Tahir, Amjed and Blincoe, Kelly},
	month = may,
	year = {2019},
	pages = {349--359},
	file = {Dietrich 等 - 2019 - Dependency Versioning in the Wild.pdf:/home/kanade/Zotero/storage/P9IGH6KI/Dietrich 等 - 2019 - Dependency Versioning in the Wild.pdf:application/pdf},
}

@article{decan_what_2021,
	title = {What {Do} {Package} {Dependencies} {Tell} {Us} {About} {Semantic} {Versioning}?},
	volume = {47},
	issn = {1939-3520},
	url = {https://ieeexplore.ieee.org/abstract/document/8721084},
	doi = {10.1109/TSE.2019.2918315},
	abstract = {The semantic versioning (semver) policy is commonly accepted by open source package management systems to inform whether new releases of software packages introduce possibly backward incompatible changes. Maintainers depending on such packages can use this information to avoid or reduce the risk of breaking changes in their own packages by specifying version constraints on their dependencies. Depending on the amount of control a package maintainer desires to have over her package dependencies, these constraints can range from very permissive to very restrictive. This article empirically compares semver compliance of four software packaging ecosystems (Cargo, npm, Packagist and Rubygems), and studies how this compliance evolves over time. We explore to what extent ecosystem-specific characteristics or policies influence the degree of compliance. We also propose an evaluation based on the “wisdom of the crowds” principle to help package maintainers decide which type of version constraints they should impose on their dependencies.},
	number = {6},
	urldate = {2024-05-14},
	journal = {IEEE Transactions on Software Engineering},
	author = {Decan, Alexandre and Mens, Tom},
	month = jun,
	year = {2021},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Software, Computer bugs, configuration management, distribution, maintenance, and enhancement, Ecosystems, Java, Libraries, maintainability, metrics/measurement, Packaging, reusable libraries, reusable software, Semantics, Software engineering, software release management and delivery, version control},
	pages = {1226--1240},
	file = {IEEE Xplore Abstract Record:/home/kanade/Zotero/storage/ZAH4GRAL/8721084.html:text/html;IEEE Xplore Full Text PDF:/home/kanade/Zotero/storage/9ISAAF4V/Decan 和 Mens - 2021 - What Do Package Dependencies Tell Us About Semanti.pdf:application/pdf},
}

@inproceedings{kikas_structure_2017,
	title = {Structure and {Evolution} of {Package} {Dependency} {Networks}},
	url = {https://ieeexplore.ieee.org/document/7962360},
	doi = {10.1109/MSR.2017.55},
	abstract = {Software developers often include available open-source software packages into their projects to minimize redundant effort. However, adding a package to a project can also introduce risks, which can propagate through multiple levels of dependencies. Currently, not much is known about the structure of open-source package ecosystems of popular programming languages and the extent to which transitive bug propagation is possible. This paper analyzes the dependency network structure and evolution of the JavaScript, Ruby, and Rust ecosystems. The reported results reveal significant differences across language ecosystems. The results indicate that the number of transitive dependencies for JavaScript has grown 60\% over the last year, suggesting that developers should look more carefully into their dependencies to understand what exactly is included. The study also reveals that vulnerability to a removal of the most popular package is increasing, yet most other packages have a decreasing impact on vulnerability. The findings of this study can inform the development of dependency management tools.},
	urldate = {2024-05-14},
	booktitle = {2017 {IEEE}/{ACM} 14th {International} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
	author = {Kikas, Riivo and Gousios, Georgios and Dumas, Marlon and Pfahl, Dietmar},
	month = may,
	year = {2017},
	keywords = {Computer bugs, Ecosystems, Libraries, Computer languages, dependency management, mining software repositories, software ecosystems, software evolution, Software packages, Tools},
	pages = {102--112},
	file = {IEEE Xplore Abstract Record:/home/kanade/Zotero/storage/5E2M7KN2/7962360.html:text/html;IEEE Xplore Full Text PDF:/home/kanade/Zotero/storage/6YS45TFX/Kikas 等 - 2017 - Structure and Evolution of Package Dependency Netw.pdf:application/pdf},
}

@inproceedings{artho_why_2012,
	title = {Why {Do} {Software} {Packages} {Conflict}?},
	url = {https://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-199130},
	abstract = {Why Do Software Packages Conflict?},
	language = {eng},
	urldate = {2024-05-14},
	author = {Artho, Cyrille and Suzaki, Kuniyasu and Cosmo, Roberto di and Treinen, Ralf and Zacchiroli, Stefano},
	year = {2012},
	pages = {141--150},
	file = {Full Text PDF:/home/kanade/Zotero/storage/SELVYTG3/Artho 等 - 2012 - Why Do Software Packages Conflict.pdf:application/pdf},
}

@inproceedings{foundjem_release_2019,
	address = {Montreal, Quebec, Canada},
	series = {{ICSE} '19},
	title = {Release synchronization in software ecosystems},
	url = {https://dl.acm.org/doi/10.1109/ICSE-Companion.2019.00058},
	doi = {10.1109/ICSE-Companion.2019.00058},
	abstract = {Software ecosystems bring value by integrating projects related to a given domain, for example, open source projects in a Linux distribution or mobile apps on the Android platform. However, the major challenge of managing an infrastructure ecosystem like OpenStack or Debian is to provide a polished, well-integrated product to the end user, since each individual project has its own release cycle and roadmap. To understand how modern ecosystems deal with this challenge, I empirically study the release synchronization strategy of the OpenStack ecosystem, in which a central release management team manages the six-month release cycle of the overall OpenStack product. By studying one year of release team IRC meeting logs, 9 major federated release management activities were identified, which were cataloged and documented. My findings suggest that even though an ecosystem's power lies in the interaction of autonomous projects, release synchronization is a non-trivial goal. Currently, I am performing interviews with key software developers within the OpenStack ecosystem, in order to understand the major release activities.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 41st {International} {Conference} on {Software} {Engineering}: {Companion} {Proceedings}},
	publisher = {IEEE Press},
	author = {Foundjem, Armstrong},
	month = may,
	year = {2019},
	pages = {135--137},
	file = {Full Text PDF:/home/kanade/Zotero/storage/NSG5IIDZ/Foundjem - 2019 - Release synchronization in software ecosystems.pdf:application/pdf},
}

@inproceedings{miranda_use_2018,
	address = {Pau France},
	title = {On the use of package managers by the {C}++ open-source community},
	isbn = {978-1-4503-5191-1},
	url = {https://dl.acm.org/doi/10.1145/3167132.3167290},
	doi = {10.1145/3167132.3167290},
	abstract = {THIS IS A PRE-PRINT COPY The use of package managers is commonplace for software developers working with programming languages such as Ruby, Python, and JavaScript. This is not the case for C++ developers, which present a low adoption rate of package managers.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 33rd {Annual} {ACM} {Symposium} on {Applied} {Computing}},
	publisher = {ACM},
	author = {Miranda, André and Pimentel, João},
	month = apr,
	year = {2018},
	pages = {1483--1491},
	file = {Miranda 和 Pimentel - 2018 - On the use of package managers by the C++ open-sou.pdf:/home/kanade/Zotero/storage/RUICFTNG/Miranda 和 Pimentel - 2018 - On the use of package managers by the C++ open-sou.pdf:application/pdf},
}

@article{thompson_reflections_nodate,
	title = {Reflections on {Trusting} {Trust}},
	language = {en},
	author = {Thompson, Ken},
	file = {Thompson - Reflections on Trusting Trust.pdf:/home/kanade/Zotero/storage/ZKACE4IS/Thompson - Reflections on Trusting Trust.pdf:application/pdf},
}

@inproceedings{androulaki_hyperledger_2018,
	address = {New York, NY, USA},
	series = {{EuroSys} '18},
	title = {Hyperledger fabric: a distributed operating system for permissioned blockchains},
	isbn = {978-1-4503-5584-1},
	shorttitle = {Hyperledger fabric},
	url = {https://dl.acm.org/doi/10.1145/3190508.3190538},
	doi = {10.1145/3190508.3190538},
	abstract = {Fabric is a modular and extensible open-source system for deploying and operating permissioned blockchains and one of the Hyperledger projects hosted by the Linux Foundation (www.hyperledger.org). Fabric is the first truly extensible blockchain system for running distributed applications. It supports modular consensus protocols, which allows the system to be tailored to particular use cases and trust models. Fabric is also the first blockchain system that runs distributed applications written in standard, general-purpose programming languages, without systemic dependency on a native cryptocurrency. This stands in sharp contrast to existing block-chain platforms that require "smart-contracts" to be written in domain-specific languages or rely on a cryptocurrency. Fabric realizes the permissioned model using a portable notion of membership, which may be integrated with industry-standard identity management. To support such flexibility, Fabric introduces an entirely novel blockchain design and revamps the way blockchains cope with non-determinism, resource exhaustion, and performance attacks. This paper describes Fabric, its architecture, the rationale behind various design decisions, its most prominent implementation aspects, as well as its distributed application programming model. We further evaluate Fabric by implementing and benchmarking a Bitcoin-inspired digital currency. We show that Fabric achieves end-to-end throughput of more than 3500 transactions per second in certain popular deployment configurations, with sub-second latency, scaling well to over 100 peers.},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the {Thirteenth} {EuroSys} {Conference}},
	publisher = {Association for Computing Machinery},
	author = {Androulaki, Elli and Barger, Artem and Bortnikov, Vita and Cachin, Christian and Christidis, Konstantinos and De Caro, Angelo and Enyeart, David and Ferris, Christopher and Laventman, Gennady and Manevich, Yacov and Muralidharan, Srinivasan and Murthy, Chet and Nguyen, Binh and Sethi, Manish and Singh, Gari and Smith, Keith and Sorniotti, Alessandro and Stathakopoulou, Chrysoula and Vukolić, Marko and Cocco, Sharon Weed and Yellick, Jason},
	month = apr,
	year = {2018},
	pages = {1--15},
	file = {Full Text PDF:/home/kanade/Zotero/storage/79L693DL/Androulaki 等 - 2018 - Hyperledger fabric a distributed operating system.pdf:application/pdf},
}

@inproceedings{muhammad_taxonomy_2019,
	address = {New York, NY, USA},
	series = {{PLOS} '19},
	title = {Taxonomy of {Package} {Management} in {Programming} {Languages} and {Operating} {Systems}},
	isbn = {978-1-4503-7017-2},
	url = {https://dl.acm.org/doi/10.1145/3365137.3365402},
	doi = {10.1145/3365137.3365402},
	abstract = {Package management is instrumental for programming languages and operating systems, and yet it is neglected by both areas as an implementation detail. For this reason, it lacks the same kind of conceptual organization: we lack terminology to classify them or to reason about their design trade-offs. In this paper, we share our experience in both OS and language-specific package manager development, categorizing families of package managers and discussing their design implications beyond particular implementations. We also identify possibilities in the still largely unexplored area of package manager interoperability.包管理对于编程语言和操作系统很有帮助，但它作为实现细节被这两个领域忽略了。出于这个原因，它缺乏同样的概念组织：我们缺乏术语来对它们进行分类或推理它们的设计权衡。在本文中，我们分享了我们在操作系统和特定语言的包管理器开发方面的经验，对包管理器系列进行了分类，并讨论了它们在特定实现之外的设计含义。我们还确定了包管理器互操作性这一尚未探索的领域的可能性。},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 10th {Workshop} on {Programming} {Languages} and {Operating} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Muhammad, Hisham and Real, Lucas C. Villa and Homer, Michael},
	month = oct,
	year = {2019},
	keywords = {package management, filesystem hierarchy, module systems, operating systems},
	pages = {60--66},
	file = {Full Text PDF:/home/kanade/Zotero/storage/E4BYKL7S/Muhammad 等 - 2019 - Taxonomy of Package Management in Programming Lang.pdf:application/pdf},
}

@inproceedings{bloemen_gentoo_2014,
	address = {New York, NY, USA},
	series = {{MSR} 2014},
	title = {Gentoo package dependencies over time},
	isbn = {978-1-4503-2863-0},
	url = {https://dl.acm.org/doi/10.1145/2597073.2597131},
	doi = {10.1145/2597073.2597131},
	abstract = {Open source distributions such as Gentoo need to accurately track dependency relations between software packages in order to install working systems. To do this, Gentoo has a carefully authored database containing those relations. In this paper, we extract the Gentoo package dependency graph and its changes over time. The final dependency graph spans 15 thousand open source projects and 80 thousand dependency relations. Furthermore, the development of this graph is tracked over time from the beginning of the Gentoo project in 2000 to the first quarter of 2012, with monthly resolution. The resulting dataset provides many opportunities for research. In this paper we explore cluster analysis to reveals meaningful relations between packages and in a separate paper we analyze changes in the dependencies over time to get insights in the innovation dynamics of open source software. 像Gentoo这样的开源发行版需要准确地跟踪软件包之间的依赖关系，以便安装有效的系统。为此，Gentoo有一个精心编写的数据库，其中包含这些关系。在本文中，我们提取了Gentoo软件包的依赖关系图及其随时间的变化。最终的依赖关系图跨越了 15000 个开源项目和 80000 个依赖关系。此外，从2000年Gentoo项目开始到2012年第一季度，该图的发展过程被跟踪，每月进行一次解析。由此产生的数据集为研究提供了许多机会。在本文中，我们探讨了聚类分析，以揭示软件包之间有意义的关系，在另一篇论文中，我们分析了依赖关系随时间的变化，以深入了解开源软件的创新动态。},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {Association for Computing Machinery},
	author = {Bloemen, Remco and Amrit, Chintan and Kuhlmann, Stefan and Ordóñez–Matamoros, Gonzalo},
	month = may,
	year = {2014},
	keywords = {dependencies, Gentoo, graph, Innovation},
	pages = {404--407},
	file = {Full Text PDF:/home/kanade/Zotero/storage/I7LDZCYD/Bloemen 等 - 2014 - Gentoo package dependencies over time.pdf:application/pdf},
}

@inproceedings{golzadeh_analysing_2019,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2019},
	title = {Analysing socio-technical congruence in the package dependency network of {Cargo}},
	isbn = {978-1-4503-5572-8},
	url = {https://dl.acm.org/doi/10.1145/3338906.3342497},
	doi = {10.1145/3338906.3342497},
	abstract = {Software package distributions form large dependency networks maintained by large communities of contributors. My PhD research will consist of analysing the evolution of the socio-technical congruence of these package dependency networks, and studying its impact on the health of the ecosystem and its community. I have started a longitudinal empirical study of Cargo's dependency network and the social (commenting) and technical (development) activities in Cargo's package repositories on GitHub, and present some preliminary findings.软件包发行版形成了由大型贡献者社区维护的大型依赖关系网络。我的博士研究将包括分析这些一揽子依赖网络的社会技术一致性的演变，并研究其对生态系统及其社区健康的影响。我已经开始对 Cargo 的依赖网络以及 GitHub 上 Cargo 软件包存储库中的社交（评论）和技术（开发）活动进行纵向实证研究，并提出了一些初步发现。},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 2019 27th {ACM} {Joint} {Meeting} on {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Golzadeh, Mehdi},
	month = aug,
	year = {2019},
	keywords = {Package dependency network, Socio-Technical congruence, Software development, Software ecosystem, Software repository mining},
	pages = {1226--1228},
	file = {Full Text PDF:/home/kanade/Zotero/storage/68HIDL3F/Golzadeh - 2019 - Analysing socio-technical congruence in the packag.pdf:application/pdf},
}

@article{cheng_revisiting_2024,
	title = {Revisiting {Knowledge}-{Based} {Inference} of {Python} {Runtime} {Environments}: {A} {Realistic} and {Adaptive} {Approach}},
	volume = {50},
	issn = {1939-3520},
	shorttitle = {Revisiting {Knowledge}-{Based} {Inference} of {Python} {Runtime} {Environments}},
	url = {https://ieeexplore.ieee.org/document/10373775},
	doi = {10.1109/TSE.2023.3346474},
	abstract = {The reuse and integration of existing code is a common practice for efficient software development. Constantly updated Python interpreters and third-party packages introduce many challenges to Python runtime environment inference. Existing knowledge-based approaches have achieved good performance but still suffer from several limitations in the real world, especially from incomplete domain knowledge. In this paper, we propose ReadPyE, a realistic and adaptive approach to Python runtime environment inference. To leverage the rich code information, we present an automated approach to the construction and maintenance of our designed Python ecosystem knowledge graph (KG). Moreover, we are the first to handle real-world challenges such as complex dependency specifications and incomplete domain knowledge. Specifically, we define a naming similarity measure to match candidate packages for unknown modules and set priorities for multiple candidate packages. ReadPyE solves the optimization problems of candidate package selection and generates compatible runtime environments step by step based on the current Python environment. The inferred environments are iteratively validated and adjusted by matched exception templates in the validation logs. The evaluation results on three real-world datasets show the superior effectiveness and good efficiency of our ReadPyE compared to the existing knowledge-based approaches. ReadPyE solves the environment-related exceptions for 79.75\% single-file code snippets, 93\% Python projects, and 63.34\% program pairs for code integration. We believe ReadPyE can help programmers reduce the time spent on inferring Python runtime environments and facilitate automated software configuration management.},
	number = {2},
	urldate = {2024-05-14},
	journal = {IEEE Transactions on Software Engineering},
	author = {Cheng, Wei and Hu, Wei and Ma, Xiaoxing},
	month = feb,
	year = {2024},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Python, configuration management, Codes, Feature extraction, Knowledge based systems, knowledge graph, knowledge-based inference, Python runtime environment, Runtime environment, Syntactics, Task analysis},
	pages = {258--279},
	file = {IEEE Xplore Abstract Record:/home/kanade/Zotero/storage/YJY57MPY/10373775.html:text/html;IEEE Xplore Full Text PDF:/home/kanade/Zotero/storage/YWI3INFM/Cheng 等 - 2024 - Revisiting Knowledge-Based Inference of Python Run.pdf:application/pdf},
}

@inproceedings{ferreira_containing_2021,
	address = {Madrid, Spain},
	series = {{ICSE} '21},
	title = {Containing {Malicious} {Package} {Updates} in npm with a {Lightweight} {Permission} {System}},
	isbn = {978-1-4503-9085-9},
	url = {https://dl.acm.org/doi/10.1109/ICSE43902.2021.00121},
	doi = {10.1109/ICSE43902.2021.00121},
	abstract = {The large amount of third-party packages available in fast-moving software ecosystems, such as Node.js/npm, enables attackers to compromise applications by pushing malicious updates to their package dependencies. Studying the npm repository, we observed that many packages in the npm repository that are used in Node.js applications perform only simple computations and do not need access to filesystem or network APIs. This offers the opportunity to enforce least-privilege design per package, protecting applications and package dependencies from malicious updates. We propose a lightweight permission system that protects Node.js applications by enforcing package permissions at runtime. We discuss the design space of solutions and show that our system makes a large number of packages much harder to be exploited, almost for free.快速发展的软件生态系统（如 Node.js/npm）中提供了大量第三方软件包，使攻击者能够通过将恶意更新推送到其软件包依赖项来破坏应用程序。通过研究 npm 存储库，我们观察到 npm 存储库中用于Node.js应用程序的许多包仅执行简单的计算，不需要访问文件系统或网络 API。这提供了对每个包强制实施最小特权设计的机会，从而保护应用程序和包依赖项免受恶意更新的影响。我们提出了一个轻量级的权限系统，通过在运行时强制执行包权限来保护Node.js应用程序。我们讨论了解决方案的设计空间，并表明我们的系统使大量软件包更难被利用，几乎是免费的。},
	urldate = {2024-05-14},
	booktitle = {Proceedings of the 43rd {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Ferreira, Gabriel and Jia, Limin and Sunshine, Joshua and Kästner, Christian},
	month = nov,
	year = {2021},
	keywords = {package management, design trade-offs, malicious package updates, permission system, sand-boxing, security, supply-chain security},
	pages = {1334--1346},
	file = {Full Text PDF:/home/kanade/Zotero/storage/GSBDG6E3/Ferreira 等 - 2021 - Containing Malicious Package Updates in npm with a.pdf:application/pdf},
}

@inproceedings{hegde_package_2021,
	title = {Package {Management} {System} in {Linux}},
	url = {https://ieeexplore.ieee.org/document/9544805},
	doi = {10.1109/ASIANCON51346.2021.9544805},
	abstract = {In the Linux environment, there are two common methods for delivering software: source code and pre-compiled binaries. Open-source software can benefit from source-code availability. Close-source software, on the other hand, requires a pre-compiled binary. Unlike Windows, Linux distributions such as Ubuntu, Red Hat, CentOS, and Debian come in a variety of flavours. Various Linux distributions necessitate the use of distinct binary installation packages. Red Hat and CentOS, for example, use. rpm packages, but Ubuntu and Debian require. deb packages. Developers must compile software on as many Linux computers as their supported Linux versions in order to create a software package appropriate for a wide range of Linux distributions. This procedure is inefficient, time-consuming, and difficult to manage. A method for creating and managing software packages is created here, that only requires one Linux machine. This system automates the export of software source code from a version control system, the editing of package configuration, the building of software packages, and the management of software versions. The packages for CPU performance libraries are built using this approach, which has been tested and utilised on a large scale. It has been found to speed up software release, usage and reduce the efforts and complexities. It's also simple to use, especially for those who aren't familiar with Linux.},
	urldate = {2024-05-14},
	booktitle = {2021 {Asian} {Conference} on {Innovation} in {Technology} ({ASIANCON})},
	author = {Hegde, Shrinidhi G and Ranjani, G},
	month = aug,
	year = {2021},
	keywords = {Software, Software packages, Codes, Computers, Control systems, Debian, Linux, Package management system, RPM, Spack, Technological innovation},
	pages = {1--6},
	file = {IEEE Xplore Abstract Record:/home/kanade/Zotero/storage/DIDN6IJZ/9544805.html:text/html;IEEE Xplore Full Text PDF:/home/kanade/Zotero/storage/KQWXZZES/Hegde 和 Ranjani - 2021 - Package Management System in Linux.pdf:application/pdf},
}

@inproceedings{mongkolluksame_management_2012,
	title = {A management system for software package distribution},
	url = {https://ieeexplore.ieee.org/document/6304372/references#references},
	abstract = {There are two popular ways to distribute software in Linux world, by distributing source code or pre-compiled binary. Source-code distribution is suitable for open-source software. However, for close-source software pre-compiled binary is the only option. Unlike Windows, there are many versions of Linux distributions, such as Ubuntu, Red Hat, CentOS, and Debian. Different Linux distributions require different binary installation package. For example, Red Hat and CentOS use .rpm package while Ubuntu and Debian need .deb package. To generate a software package suitable for many Linux distributions, developers must compile software on as many Linux machines as their supported Linux versions. This process is cumbersome, inefficient and difficult to manage. We develop a system to generate and manage software packages, which requires only one Linux machine. This system automatically exports software source code from a version control system, edits package configuration, builds software package, and manages software version. This system is tested and used on a production scale to build our network management software named NetHAM. It is shown to expedite the software release process and reduce number of computers required. In addition, it is easy to use even by someone with no Linux skill.},
	urldate = {2024-05-14},
	booktitle = {2012 {Proceedings} of {PICMET} '12: {Technology} {Management} for {Emerging} {Technologies}},
	author = {Mongkolluksame, Sophon and Issariyapat, Chavee and Pongpaibool, Panita and Meesublak, Koonlachat and Nulong, Nontaluck and Pukkawanna, Sirikarn},
	month = jul,
	year = {2012},
	note = {ISSN: 2159-5100},
	keywords = {Computer architecture, Software packages, Linux, Buildings, Operating systems, Servers},
	pages = {3529--3536},
	file = {IEEE Xplore Abstract Record:/home/kanade/Zotero/storage/7I4LRFBV/references.html:text/html;IEEE Xplore Full Text PDF:/home/kanade/Zotero/storage/ACH3ZZ5Z/Mongkolluksame 等 - 2012 - A management system for software package distribut.pdf:application/pdf},
}

@article{abate_dependency_2012,
	title = {Dependency solving: {A} separate concern in component evolution management},
	language = {en},
	author = {Abate, Pietro},
	year = {2012},
	file = {Abate - 2012 - Dependency solving A separate concern in componen.pdf:/home/kanade/Zotero/storage/IKDYLSMH/Abate - 2012 - Dependency solving A separate concern in componen.pdf:application/pdf},
}
